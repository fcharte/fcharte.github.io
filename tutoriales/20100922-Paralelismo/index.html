<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>Tutorial sobre programación y paralelismo (threads, MPI, GPGPU, WebCL)&lt;br/&gt;&lt;p class=&quot;author&quot;&gt;by Francisco Charte.&lt;/p&gt; - Torre de Babel</title>

<link href="data:text/css,pre%20%2Eoperator%2C%0Apre%20%2Eparen%20%7B%0A%20color%3A%20rgb%28104%2C%20118%2C%20135%29%0A%7D%0A%0Apre%20%2Eliteral%20%7B%0A%20color%3A%20%23990073%0A%7D%0A%0Apre%20%2Enumber%20%7B%0A%20color%3A%20%23099%3B%0A%7D%0A%0Apre%20%2Ecomment%20%7B%0A%20color%3A%20%23998%3B%0A%20font%2Dstyle%3A%20italic%0A%7D%0A%0Apre%20%2Ekeyword%20%7B%0A%20color%3A%20%23900%3B%0A%20font%2Dweight%3A%20bold%0A%7D%0A%0Apre%20%2Eidentifier%20%7B%0A%20color%3A%20rgb%280%2C%200%2C%200%29%3B%0A%7D%0A%0Apre%20%2Estring%20%7B%0A%20color%3A%20%23d14%3B%0A%7D%0A" rel="stylesheet" type="text/css" />
<!--link rel="stylesheet" href="https://assets-cdn.github.com/assets/frameworks-148da7a2b8b9ad739a5a0b8b68683fed4ac7e50ce8185f17d86aa05e75ed376e.css"-->
<link href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/5.0.0/normalize.min.css" crossorigin="anonymous">
<link href="https://fonts.googleapis.com/css?family=Inconsolata|Source+Sans+Pro:400,400i,700" rel="stylesheet">
<link rel="stylesheet" href="https://fcharte.com/assets/css/monokai.css">

<link rel="stylesheet" href="https://fcharte.com/assets/css/numbersections.css">

<link rel="stylesheet" href="https://fcharte.com/assets/css/main.css">

  </head>
  <body class="layout-post">

    <header>
  <div class="inner header-inner">
    <a class="header-title" href="https://fcharte.com">Torre de Babel</a>
    <nav class="main-navigation">
  
  <a href="https://fcharte.com/about/">Sobre mí</a>
  
  <a href="https://fcharte.com/tutoriales/">Tutoriales</a>
  
  <a href="https://fcharte.com/manuales/">Manuales</a>
  
  <a href="https://fcharte.com/docencia/">Docencia</a>
  
  <a href="https://fcharte.com/investigacion/">Investigación</a>
  
  <a href="https://fcharte.com/publicaciones/">Publicaciones</a>
  
</nav>

  </div>
</header>

    <div class="main">
      <div class="inner main-inner">
        <h1>Tutorial sobre programación y paralelismo (threads, MPI, GPGPU, WebCL)<br/><p class="author">by Francisco Charte.</p></h1>

<article>
<ul class="section-nav">
<li class="toc-entry toc-h2"><a href="#tiempo-compartido">Tiempo compartido</a></li>
<li class="toc-entry toc-h2"><a href="#threads-y-smp">Threads y SMP</a></li>
<li class="toc-entry toc-h2"><a href="#gpgpu-y-mpi">GPGPU y MPI</a></li>
<li class="toc-entry toc-h2"><a href="#cpu-vs-gpu">CPU vs GPU</a></li>
<li class="toc-entry toc-h2"><a href="#paralelismo-y-aplicaciones-web---webcl">Paralelismo y aplicaciones web - WebCL</a></li>
</ul><p>Los ordenadores no tendrían utilidad alguna si no existiesen programadores que creasen software que les hiciese funcionar y ofrecer a los usuarios finales aquello que necesitan. Dicho software puede tomar distintas formas, desde el <a href="http://es.wikipedia.org/wiki/Firmware">firmware</a> que se incluye en ROM (o alguna variante <a href="http://es.wikipedia.org/wiki/Memoria_PROM">PROM/EPROM/etc.</a>) y se encarga de la puesta en marcha y ofrece los servicios más básicos hasta las aplicaciones de control de procesos o diseño asistido, pasando por los sistemas operativos y los propios compiladores e intérpretes de multitud de lenguajes.</p>

<h2>
<a id="tiempo-compartido" class="anchor" href="#tiempo-compartido" aria-hidden="true"><span class="octicon octicon-link"></span></a>Tiempo compartido</h2>
<p>En los primeros ordenadores el software se ejecutaba en forma de <a href="http://es.wikipedia.org/wiki/Procesamiento_por_lotes">procesos por lotes</a>: cada programador ponía su tarea en cola y esperaba a que llegase su turno para obtener la salida correspondiente. Cada tarea era intrínsecamente secuencial, en el sentido de que no ejecutaba más de una instrucción de manera simultánea. Posteriormente llegaron los sistemas de <a href="http://es.wikipedia.org/wiki/Tiempo_compartido_(inform%C3%A1tica)">tiempo compartido</a> capaces de atender interactivamente a varios usuarios y, en apariencia, ejecutar múltiples tareas en paralelo, si bien la realidad era que el sistema operativo se encargaba de que el procesador fuese saltando de una tarea a otra cada pocos ciclos, consiguiendo esa <b>ilusión de paralelismo</b> o <a href="http://es.wikipedia.org/wiki/Multitarea">multitarea</a>.

</p><p>Para los programadores de un sistema operativo la implementación del tiempo compartido implicaba codificar algoritmos relativamente complejos, de los cuales el más conocido es <a href="http://en.wikipedia.org/wiki/Round-robin_scheduling">Round Robin</a>, capaces de seleccionar en cada momento el proceso que ha de pasar a ejecutarse e impedir situaciones indeseadas como, por ejemplo, que una tarea no obtenga nunca tiempo de procesador. Con el tiempo los microprocesadores implementaron en hardware una gran cantidad de lógica que facilitaba el intercambio rápido de tareas, haciendo más fácil el trabajo de los programadores de sistemas.</p>

<p>Los programadores de aplicaciones, por el contrario, siguieron durante décadas diseñando software asumiendo que sus programas obtenían el control total del ordenador, implementando los algoritmos para que se ejecutasen secuencialmente de principio a fin y dejando que el sistema operativo los interrumpiese cada cierto tiempo para volverlos a poner en marcha un instante después, todo ello a tal velocidad que los usuarios tenían la sensación esperada: la aplicación les atendía de manera continua sin problemas. Esto es especialmente cierto en aquellos programas en los que existe comunicación con el usuario, ya que la mayor parte del tiempo se encuentran a la espera de una acción por parte de éste: una entrada por teclado, la pulsación de un botón, etc.</p>

<h2>
<a id="threads-y-smp" class="anchor" href="#threads-y-smp" aria-hidden="true"><span class="octicon octicon-link"></span></a>Threads y SMP</h2>
<p>Dado que los microprocesadores solamente eran capaces de ejecutar una tarea en un instante dado, antes de que contasen con <a href="http://en.wikipedia.org/wiki/Pipeline_(computing)">pipelines</a> primero, varias unidades funcionales después (<a href="http://en.wikipedia.org/wiki/Superscalar">procesadores superescalares</a>) y múltiples núcleos finalmente; los programadores de aplicaciones que querían ejecutar más de un trabajo en paralelo recurrían a diversos <i>trucos</i>, como el uso de <i>interrupciones</i>. De esta forma era posible, por ejemplo, imprimir un documento o realizar otra tarea lenta mientras se seguía atendiendo al usuario. De ahí se pasó a la programación con múltiples hilos o <a href="http://en.wikipedia.org/wiki/Thread_(computer_science)">threads</a>, de forma que un programa podía ejecutar múltiples secuencias de instrucciones en <i>paralelo</i>. Esos hilos eran gestionados por el sistema operativo mediante el citado algoritmo de tiempo compartido: el procesador seguía ejecutando únicamente una tarea en cada instante.</p>

<p>Aunque el <a href="http://en.wikipedia.org/wiki/Symmetric_Multi-Processing">multiproceso simétrico</a> existe desde la década de los 60 en máquinas tipo <i>mainframe</i>, no fue hasta finales de los 90 cuando los servidores y estaciones de trabajo con zócalos para dos procesadores se hicieron suficientemente asequibles como para adquirir cierta popularidad. Estas máquinas contaban con dos procesadores y, en consecuencia, tenían capacidad para ejecutar dos tareas con <i>paralelismo real</i>. Obviamente los algoritmos de tiempo compartido seguían estando presentes, ya que el número de procesos en ejecución suele ser mucho mayor, pero el rendimiento era muy superior al ofrecido por los ordenadores personales.</p>

<h2>
<a id="gpgpu-y-mpi" class="anchor" href="#gpgpu-y-mpi" aria-hidden="true"><span class="octicon octicon-link"></span></a>GPGPU y MPI</h2>
<p>El escenario de la computación personal ha cambiado drásticamente desde el inicio del nuevo milenio. Si en los años previos los fabricantes de microprocesadores competían casi exclusivamente en velocidad, lo que permitía al software aprovechar la mayor potencia sin trabajo adicional por parte del programador, en la última década han aparecido los <b>microprocesadores multinúcleo</b> y los procesadores gráficos con capacidades <a href="http://gpgpu.org/">GPGPU (<i>General-Purpose Computation on Graphics Hardware</i>)</a>, lo que ha traído el final del <a href="http://en.wikipedia.org/wiki/The_Free_Lunch_Is_Over_(computing)"><i>Free Lunch</i></a> para los programadores. Ahora aprovechar la potencia de un ordenador implica necesariamente el uso de todo ese paralelismo de una forma u otra.</p>

<p>A los microprocesadores multinúcleo y las GPU habría que sumar una opción cada vez más alcance de cualquiera: los <a href="http://es.wikipedia.org/wiki/Cluster_(inform%C3%A1tica)">cluster de ordenadores</a>. Si bien antes eran una opción reservada a centros de supercomputación, en la actualidad hay multitud de usuarios que disponen de varias máquinas conectadas en red local, lo cual abre las puertas (con el software adecuado) a la configuración en cluster para aprovechar el paralelismo y ejecutar software distribuyendo el trabajo entre múltiples máquinas.</p>

<p>En conjunto la popularización de estos mecanismos de paralelización implican la aparición de un nuevo modelo de diseño de software y el <b>necesario reciclaje de los programadores</b>. Ya no basta con escribir sentencias que se ejecutarán una tras otra, sin más, siendo preciso planificar una arquitectura de mayor complejidad si se quiere obtener el mayor beneficio del hardware disponible. Algunas ideas al respecto:</p>
<ul class="enumeracion">
<li>Distribuir el trabajo a realizar entre varios ordenadores conectados en red local es una tarea relativamente simple gracias a <a href="http://en.wikipedia.org/wiki/Message_Passing_Interface">MPI (<i>Message Passing Interface</i>)</a>, una interfaz de la que existen múltiples implementaciones para diferentes sistemas operativos. Personalmente he usado <a href="http://www.open-mpi.org/">Open MPI</a>, una implementación <i>Open Source</i> de MPI, y su funcionamiento en un cluster con red Ethernet es muy simple.
</li>
<li>En cada una de los ordenadores del cluster (o el único ordenador si no se dispone de uno) el software ha de estructurarse de forma que se aprovechen al máximo los núcleos con que cuente el microprocesador. Esto implica trabajar con múltiples hilos, algo realmente simple en la plataforma Java o la plataforma .NET y que en el caso de lenguajes como C/C++ significa recurrir a bibliotecas como <a href="http://en.wikipedia.org/wiki/POSIX_Threads">POSIX threads</a>.
</li>
<li>Si los ordenadores en que se ejecute el software cuentan con hardware de vídeo de última generación, todos aquellos procesos con alto nivel de paralelismo tipo <a href="http://es.wikipedia.org/wiki/SIMD">SIMD (<i>Single Instruction Multiple Data</i>)</a> pueden acelerarse hasta un punto realmente sorprendente, ya que las GPU pueden realizar en un ciclo operaciones en paralelo sobre 256, 320 e incluso más operandos, mientras que un microprocesador tendría que recurrir a un bucle y consumir un número mucho mayor de ciclos. Hasta no hace mucho programar tareas a ejecutar en una GPU tenía el inconveniente de que cada fabricante ofrecía su solución propietaria: <a href="http://www.nvidia.es/object/what_is_cuda_new_es.html">CUDA en el caso de NVidia</a> (es la opción que he usado en algunas ocasiones y sobre la que publiqué un artículo hace aproximadamente un año en una conocida revista española) o <a href="http://www.amd.com/US/PRODUCTS/TECHNOLOGIES/STREAM-TECHNOLOGY/Pages/stream-technology.aspx">Stream en el de ATI</a>. Desde hace algo más de un año existe otra opción: <a href="http://www.khronos.org/opencl/">OpenCL</a>, un estándar que no solamente funciona con GPU de diferentes fabricantes sino que, además, está diseñado para repartir tareas entre CPU y GPU. Una opción adicional, siempre que se trabaje sobre Windows, es <a href="http://en.wikipedia.org/wiki/DirectCompute">DirectCompute</a>, una API similar a OpenCL que hace posible la programación GPGPU sin que importe el fabricante de hardware.
</li>
</ul>
<p>El <a href="http://www.khronos.org/opencl/">Grupo Khronos</a> ha hecho pública recientemente la versión 1.1 de OpenCL y tanto ATI como NVidia ofrecen controladores para esta API, por lo que posiblemente sea la mejor alternativa si uno no quiere atarse a la oferta de una determinada empresa.</p>
<p>Aprender a usar estas herramientas será (sino lo es ya) un requisito indispensable para cualquier programador, no exclusivamente para los desarrolladores de software de sistemas. El proceso, sin embargo, será lento y mientras tanto el hardware de que disponemos en nuestro escritorio estará muy infrautilizado, ya que muy pocas aplicaciones aprovechan su potencia. El sistema operativo utiliza los múltiples núcleos de los actuales microprocesadores para repartir la carga de trabajo, pero apenas hace uso de la GPU. De hecho las GPU, salvo en el caso de los juegos y algunas aplicaciones específicas de gráficos/vídeo, son el recurso mas desaprovechado. La próxima generación de navegadores, no obstante, promete hacer uso de esa potencia a través de la aceleración por hardware de la composición de páginas.</p>

<h2>
<a id="cpu-vs-gpu" class="anchor" href="#cpu-vs-gpu" aria-hidden="true"><span class="octicon octicon-link"></span></a>CPU vs GPU</h2>
<p>Todos los ordenadores cuentan con una <a href="http://en.wikipedia.org/wiki/Central_processing_unit">CPU o microprocesador</a> (en ocasiones con varios) y, desde hace unos años, dichos circuitos integrados dejaron de competir en velocidad bruta, regida únicamente por la frecuencia de funcionamiento, para incrementar su potencia por otra vía: la integración de <b>múltiples núcleos</b>. Una configuración hardware con un único microprocesador de 4 núcleos resulta mucho más barata que otra que cuente con 4 microprocesadores (que también existen) de un único núcleo, ya que en la placa base es necesario un único zócalo y el número de interconexiones es también mucho menor, aparte de que fabricar un único <i>chip</i> es más barato que fabricar cuatro. La potencia de estos dos hipotéticos sistemas no es idéntica, pero sí muy similar.</p>

<p>Además de varios núcleos ciertos fabricantes, como es el caso de <a href="http://en.wikipedia.org/wiki/HyperThreading">Intel con su tecnología Hyperthreading</a>, diseñan sus microprocesadores de manera que cada núcleo (duplicando ciertas unidades operativas) tiene capacidad para ejecutar dos hilos simultáneamente. Con un micro de 4 núcleos podrían ejecutarse 8 hilos con paralelismo real (sin recurrir a técnicas de tiempo compartido). Este fabricante ya cuenta con microprocesadores que ofrecen 6 núcleos/12 hilos y en muestras de tecnología futura, puesta a disposición de universidades, experimenta con un <i>chip</i> que dispone de <a href="http://www.intel.com/pressroom/archive/releases/2009/20091202comp_sm.htm#story">48 núcleos</a>. Es fácil darse cuenta de que en pocos años tendremos ordenadores cuyas CPU integrarán <b>decenas sino cientos</b> de núcleos, equivalente cada uno de ellos a un procesador tipo <i>Pentium</i>.</p>

<p>La escalada del número de núcleos integrados en un mismo circuito no se inició, sin embargo, en el campo de las CPU, sino que viene precedida por una carrera similar en el de <a href="http://en.wikipedia.org/wiki/GPU">las GPU</a> desde hace ya varios años, producto de la directa competencia entre <a href="http://www.nvidia.es/page/home.html">nVidia</a> y <a href="http://www.amd.com/es/Pages/AMDHomePage.aspx">ATI (ahora AMD)</a>. Los productos de estos fabricantes hace tiempo que se componen de <b>cientos de núcleos</b> de procesamiento y grandes cantidades de memoria, ofreciendo una potencia impensable hasta hace muy poco. Aunque en un principio esos núcleos se empleaban exclusivamente para ejecutar <i>shaders</i>, pequeños programas encargados de realizar transformaciones sobre vértices, aplicar texturas, cálculos de iluminación, etc., (véase la serie sobre <i>shaders</i> que he ido publicando en los últimos meses, en el margen derecho), gracias a las <a href="http://en.wikipedia.org/wiki/GPGPU">técnicas GPGPU</a> ahora también es posible usarlos para otros fines.</p>

<p>A pesar de que la denominación <b>núcleo</b> ha sido utilizada tanto por fabricantes de GPU como de CPU, debe tenerse en cuenta que no hace referencia exactamente al mismo concepto. En una CPU <b>cada núcleo es equivalente a un microprocesador completo</b>, con sus propios registros, unidades aritméticas y de ejecución e incluso memoria propia, si bien comparte también memoria con los demás núcleos, así como las líneas de entrada/salida y buses que permiten a la CPU comunicarse con el exterior. Los núcleos de una GPU son mucho más <i>sencillos</i>, básicamente unidades aritmético-lógicas con capacidad para operar en coma flotante y llevar a cabo algunas operaciones específicas, pero no ejecutar código de propósito general.</p>

<p>A la hora de planificar el grado de concurrencia de un software o algoritmo hay que diferenciar, por tanto, entre <a href="http://en.wikipedia.org/wiki/SIMD">paralelismo SIMD</a> y <a href="http://en.wikipedia.org/wiki/MIMD">paralelismo MIMD</a>. Las GPU son ideales para el primer caso, en el que un <b>mismo conjunto de sentencias</b> se aplica simultáneamente sobre <b>múltiples datos independientes entre sí</b>, produciendo por lo general tantos resultados como datos de entrada existan. Es una configuración ideal para, por ejemplo, realizar operaciones sobre matrices que, dependiendo de su tamaño, pueden ser calculadas en un único ciclo de reloj. Para paralelizar tareas del segundo tipo, en las que <b>flujos de sentencias diferentes</b> se aplican sobre conjuntos de datos que pueden ser independientes o no, es necesario recurrir a los núcleos de la CPU, ya que cada uno de ellos puede ejecutar un programa distinto: un núcleo puede controlar la interfaz de usuario de un programa mientras otro se dedica a procesar datos introducidos en dicha interfaz, tareas paralelas pero que no tienen mucho que ver entre sí.</p>

<p>Estas diferencias entre un tipo de paralelismo y otro dan lugar también a diferentes <b>modelos de programación</b>. Las tareas a ejecutar en los núcleos de un procesador se implementan como <b>hilos o <i>threads</i></b>. Incluso cuando no se crean explícitamente, cada programa/proceso tiene asociado al menos un hilo de ejecución que se encarga de procesar el <b>flujo principal de sentencias</b>. Los sistemas operativos cuentan con una API de bajo nivel para la creación y control de hilos, siendo mucho más habitual el uso de los servicios de alto nivel que ofrecen la mayoría de plataformas y lenguajes para esta tarea, dejándoles la gestión de los detalles más delicados. Incluso hay plataformas/lenguajes, como es el caso de <a href="http://en.wikipedia.org/wiki/Erlang_(programming_language)">Erlang</a>, en los que este paralelismo es prácticamente implícito sin necesidad de vérselas con los hilos.</p>

<p>En contraposición, las tareas de tipo SIMD a ejecutar en una GPU se implementan como un <i>kernel</i> o porción de código que se aplicará en paralelo sobre todos los datos a tratar, sería equivalente a tener <b>múltiples hilos ejecutando exactamente las mismas sentencias</b> pero cada uno de ellos sobre un dato diferente de una estructura mayor. Ese grupo de sentencias suele ser breve, llevando a cabo operaciones relativamente sencillas. A diferencia de lo que ocurre con los hilos, ni sistemas operativos ni plataformas/lenguajes (como .NET o Java) permiten crear este tipo de programas para ejecutarlos en GPU, siendo necesario recurrir a soluciones dependientes de cada fabricante como puede ser <a href="http://www.nvidia.es/object/what_is_cuda_new_es.html">CUDA en el caso de NVidia</a> o <a href="http://www.amd.com/US/PRODUCTS/TECHNOLOGIES/STREAM-TECHNOLOGY/Pages/stream-technology.aspx">Stream en el de ATI</a>.</p>

<p>¿Cómo podría una misma aplicación, con el objetivo de explotar toda la potencia de un ordenador actual, aprovechar tanto el paralelismo de la CPU como de la GPU? Hasta no hace tanto esto implicaba crear hilos en la CPU para las tareas MIMD y <i>kernels</i> en la GPU para las tareas SIMD, con herramientas distintas y en ocasiones lenguajes de programación distintos, integrando los diversos componentes de la mejor manera posible. Una alternativa que cuenta con el favor de una gran parte de la industria es <a href="http://www.khronos.org/opencl/">OpenCL</a>, un estándar que hace posible la ejecución de código escrito en C/C++ distribuyendo las tareas entre CPU y GPU, sin que importe el fabricante de la GPU. Esa capacidad, no obstante, es actualmente <i>teórica</i> en un escenario en el que cada empresa intenta favorecer su oferta sobre la de la competencia.</p>

<p>Si se cuenta con un hardware gráfico de nVidia, los controladores OpenCL de esta empresa solamente reconocerán como dispositivo la propia GPU, tal y como se aprecia en la ventana de la izquierda de la imagen inferior. Los controladores de ATI/AMD (menos avanzados que los de nVidia en el soporte OpenCL), por el contrario, sí reconocen la CPU como dispositivo (ventana de la derecha), pero obviamente no pueden usar la GPU de nVidia.</p>
 
<p style="text-align:center"><image src="http://www.fcharte.com/imagenes/gpucaps.png" title="Soporte OpenCL en distintas plataformas"></image></p>

<p>Es necesario, por tanto, contar con una configuración hardware específica si se quiere usar OpenCL o, de lo contrario, recurrir a la oferta específica de cada fabricante: CUDA o Stream. Una opción adicional, pero que tal como indiqué en la entrada antes citada es válida únicamente para Windows, sería <a href="http://en.wikipedia.org/wiki/DirectCompute">DirectCompute</a>, una API similar a OpenCL que hace posible la programación GPGPU sin que importe el fabricante de hardware. En realidad ésta es una verdad a medias, ya que recientemente <del>Microsoft</del> <b>el equipo de desarrollo de Mesa/Galium3D</b> anunció que habrá una <a href="http://www.phoronix.com/scan.php?page=article&amp;item=mesa_gallium3d_d3d11&amp;num=1">implementación nativa de DirectX 10/11 para Linux</a>, lo cual permitiría usar DirectCompute en Windows/Linux (por ahora no en Mac) sin que importe el fabricante.</p>

<p>Otra alternativa más, aunque habrá que esperar para ver qué ofrece, sería usar <a href="http://arstechnica.com/business/news/2010/09/nvidia-ports-its-cuda-gpu-programming-architecture-to-x86.ars">CUDA para x86</a>, una versión de CUDA que se ejecutaría sobre las actuales CPU y que acaba de ser anunciada por nVidia. Todavía no conozco los detalles, pero es de suponer que esto permitirá usar CUDA para ejecutar código tanto en la GPU como en la CPU, situando a CUDA como el competidor más directo de OpenCL que, anecdóticamente, debe gran parte de su desarrollo a la propia nVidia.</p>

<h2>
<a id="paralelismo-y-aplicaciones-web---webcl" class="anchor" href="#paralelismo-y-aplicaciones-web---webcl" aria-hidden="true"><span class="octicon octicon-link"></span></a>Paralelismo y aplicaciones web - WebCL</h2>
<p>La única vía que hay actualmente para obtener provecho del gran rendimiento que ofrece el hardware, tanto los microprocesadores <i>multi-core</i> (CPU) como las GPU con sus cientos de núcleos de procesamiento, pasa por un rediseño del software a fin de afrontar explícitamente el paralelismo.Ya se han descrito en los apartados previos las diferentes opciones a disposición de los desarrolladores: <i>threads</i>, MPI, CUDA, OpenCL, etc., habiéndose establecido las diferencias fundamentales entre paralelismo en CPU y en GPU.</p>

<p>Al tratar el tema del paralelismo siempre se asume que el objetivo es emplearlo en programas que serán instalados y ejecutados en un ordenador de forma nativa, ya sea a través de compiladores específicos para un hardware concreto o el uso de máquinas virtuales que se ocupan de los detalles de más bajo nivel. En cualquier caso son aplicaciones dirigidas a funcionar bajo una cierta configuración: microprocesador, GPU, sistema operativo, etc. De un tiempo a esta parte, sin embargo, la web está ganando terreno rápidamente como plataforma para la ejecución de aplicaciones superando esas especificidades, no precisando más que un navegador que se ajuste a los estándares: <a href="http://dev.w3.org/html5/spec/Overview.html">HTML5</a>, <a href="http://www.w3.org/TR/css-2010/">CSS3</a> y <a href="http://www.ecma-international.org/publications/standards/Ecma-262.htm">Javascript</a>.
</p><p>El código Javascript de una aplicación web puede ejecutar código en múltiples hilos en la CPU gracias a los <a href="http://www.w3.org/TR/workers/">Web Workers</a> pero, hasta el momento, no existía un método que permitiese aprovechar la gran potencia con la que cuentan las GPU actuales con independencia del hardware, sistema operativo o navegador que el usuario emplee para acceder a la aplicación web. Por suerte es una situación que, todo parece indicar, cambiará en un futuro reciente gracias a <http:></http:>WebCL.</p>
<p>WebCL es a las aplicaciones web lo que OpenCL a las aplicaciones nativas: una capa de abstracción que permite ejecutar código en paralelo tanto en CPU como en GPU, sin importar el fabricante del hardware ni el sistema operativo empleado. Sobre OpenCL ya escribí en <a href="http://fcharte.com/Default.asp?noticias=2&amp;a=2010&amp;m=9&amp;d=22">Programación y paralelismo (CPU vs GPU)</a> y en <a href="http://fcharte.com/Default.asp?noticias=2&amp;a=2010&amp;m=10&amp;d=29">Python + OpenCL = PyOpenCL</a>. Es un estándar regido por el <a href="http://www.khronos.org/">Khronos Group</a> y que siguen múltiples fabricantes de hardware, entre ellos AMD/ATI, nVidia e Intel. En realidad WebCL es, fundamentalmente, un enlace o <i>binding</i> para poder acceder a OpenCL desde Javascript.</p>
<p>WebCL es un estándar en desarrollo y ningún navegador lo incluye <i>de serie</i> actualmente. Para poder probarlo es necesario instalar un complemento en el navegador y, por el momento y hasta donde sé, únicamente hay dos disponibles: un <a href="http://code.google.com/p/webcl/">prototipo de Samsung para Webkit</a> que puede utilizarse en Safari sobre MacOS X (10.6 ó 10.7) y otro <a href="http://webcl.nokiaresearch.com/">de Nokia para Firefox 6</a> disponible para Windows y Linux (en versiones de 32 bits). Una vez instalado el complemento es posible crear desde Javascript un objeto <code>WebCLComputeContext</code> (en la implementación de Samsung) y usarlo para obtener información sobre el hardware disponible, preparar el código a ejecutar paralelamente y enviarlo a la CPU/GPU.</p>
<p>WebCL está dando sus primeros pasos. El grupo de trabajo encargado de este estándar dentro del Khronos Groups fue creado el pasado mes de mayo y, en principio, su objetivo es facilitar una guía de implementación para fabricantes conservando la esencia de OpenCL y poniendo especial énfasis en el tema de la seguridad, ya que el código se ejecutaría en el ordenador de los usuarios al acceder a una aplicación desde su navegador, sin necesidad de instalar ni ejecutar explícitamente un programa externo. En la presentación de más abajo, realizada por el Khronos Group, se ofrecen algunos ejemplos y enlaces a vídeos demostrativos del uso de WebCL y su integración con WebGL.</p>

<iframe src="http://docs.google.com/gview?url=http://www.khronos.org/webgl/wiki_1_15/images/WebCL_Overview_and_Demo_DevCon5.pdf&amp;embedded=true" style="width:700px; height:800px;margin-left:auto;margin-right:auto" frameborder="1"></iframe>
<p></p>
</article>

      </div>
    </div>

    <footer>
  <div class="inner footer-inner">
    <div>
      &copy; 1997-2024 Francisco Charte.
      
      <nav class="main-navigation">
  
  <a href="https://www.researchgate.net/profile/F_Charte">ResearchGate</a>
  
  <a href="http://orcid.org/0000-0002-3083-8942">ORCID</a>
  
  <a href="https://github.com/fcharte">GitHub</a>
  
  <a href="https://scholar.google.es/citations?user=i8l_80EAAAAJ&hl=es">Google Scholar</a>
  
  <a href="https://www.youtube.com/fcharte">YouTube!</a>
  
</nav>

      
    </div>
  </div>
</footer>


  </body>
</html>
