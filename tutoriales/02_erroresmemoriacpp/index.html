<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>Cómo evitar problemas con la asignación dinámica de memoria en C&lt;br/&gt;&lt;p class=&quot;author&quot;&gt;by Francisco Charte.&lt;/p&gt; - Torre de Babel</title>

<link href="data:text/css,pre%20%2Eoperator%2C%0Apre%20%2Eparen%20%7B%0A%20color%3A%20rgb%28104%2C%20118%2C%20135%29%0A%7D%0A%0Apre%20%2Eliteral%20%7B%0A%20color%3A%20%23990073%0A%7D%0A%0Apre%20%2Enumber%20%7B%0A%20color%3A%20%23099%3B%0A%7D%0A%0Apre%20%2Ecomment%20%7B%0A%20color%3A%20%23998%3B%0A%20font%2Dstyle%3A%20italic%0A%7D%0A%0Apre%20%2Ekeyword%20%7B%0A%20color%3A%20%23900%3B%0A%20font%2Dweight%3A%20bold%0A%7D%0A%0Apre%20%2Eidentifier%20%7B%0A%20color%3A%20rgb%280%2C%200%2C%200%29%3B%0A%7D%0A%0Apre%20%2Estring%20%7B%0A%20color%3A%20%23d14%3B%0A%7D%0A" rel="stylesheet" type="text/css" />
<!--link rel="stylesheet" href="https://assets-cdn.github.com/assets/frameworks-148da7a2b8b9ad739a5a0b8b68683fed4ac7e50ce8185f17d86aa05e75ed376e.css"-->

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/5.0.0/normalize.min.css" crossorigin="anonymous">
<link href="https://fonts.googleapis.com/css?family=Inconsolata|Source+Sans+Pro:400,400i,700" rel="stylesheet">
<link rel="stylesheet" href="https://fcharte.com/assets/css/monokai.css">

<link rel="stylesheet" href="https://fcharte.com/assets/css/numbersections.css">

<link rel="stylesheet" href="https://fcharte.com/assets/css/main.css">

  </head>
  <body class="layout-post">

    <header>
  <div class="inner header-inner">
    <a class="header-title" href="https://fcharte.com">Torre de Babel</a>
    <nav class="main-navigation">
  
  <a href="https://fcharte.com/about/">Sobre mí</a>
  
  <a href="https://fcharte.com/tutoriales/">Tutoriales</a>
  
  <a href="https://fcharte.com/manuales/">Manuales</a>
  
  <a href="https://fcharte.com/docencia/">Docencia</a>
  
  <a href="https://fcharte.com/investigacion/">Investigación</a>
  
  <a href="https://fcharte.com/publicaciones/">Publicaciones</a>
  
</nav>

  </div>
</header>

    <div class="main">
      <div class="inner main-inner">
        <h1>Cómo evitar problemas con la asignación dinámica de memoria en C<br/><p class="author">by Francisco Charte.</p></h1>

<article>
<ul class="section-nav">
</ul><p>Todos los que programamos con C/C++, incluso los que nos consideramos experimentados, solemos emplear una significativa cantidad de tiempo depurando errores siempre relacionados con el mismo tema: la asignación dinámica de memoria. Siguiendo una serie de reglas básicas podemos reducir apreciablemente este tipo de fallos:</p><ol>
<li>Antes de usar un puntero comprobar que no es <code>NULL</code>. Introducir un <code>if(q) usa_q_como_sea;</code> nos ahorrará muchos disgustos.</li>
<li>Asignar el valor <code>NULL</code> a todo puntero sin inicializar. Acostumbrarse a escribir <code>char* q = NULL</code> es una buena costumbre.</li>
<li>Tras asignar memoria dinámicamente, inicializarla de inmediato. Tras un <code>q = malloc(sizeof(X))</code> siempre un <code>memset(q,0,sizeof(X))</code>, así evitaremos usar la basura que hay en la memoria sin inicializar.</li>
<li>Usar siempre <code>strncpy()</code> y <code>strncat()</code> al operar sobre cadenas asignadas dinámicamente, así evitaremos escribir más allá del tamaño del bloque, en zonas de memoria que no nos pertenecen.</li>
<li>No calcular nunca a mano el tamaño de los operandos, en su lugar recurrir siempre al operador <code>sizeof()</code>. El tamaño de los tipos básicos y la alineación de los campos en las estructuras alteran el espacio que se ocupa.</li>
<li>Al trabajar con cadenas, no olvidar que si hemos asignado <code>N</code> bytes dinámicamente, sólo podremos almacenar <code>N-1</code> caracteres. Obvio, pero fuente de muchos quebraderos de cabeza.</li>
<li>Antes de asignar a un puntero no nulo otra dirección, no olvidar liberar la memoria previamente asignada. La construcción <code>if(q) free(q)</code> ha de ser una costumbre antes de reutilizar una variable puntero.</li>
<li>Cada <code>free(q)</code> irá siempre seguido de un <code>q = NULL</code>, así evitaremos acceder a bloques de memoria que ya hemos liberado.</li>
<li>Moldear siempre los punteros al tipo correcto, de lo contrario la aritmética de punteros no funcionará. Una operación del tipo <code>q++</code> nos llevará a una dirección u otra dependiendo del tipo de <code>q</code>.</li>
<li>Antes de usar un puntero comprobar que no es <code>NULL</code>. Esta regla, primera y última, es fundamental y nunca suficientemente repetida. Comprobar siempre que un puntero no es <code>NULL</code> antes de leer o escribir con él.</li>
</ol><p>Espero que estas indicaciones puedan ser de alguna utilidad a los que programan diariamente utilizando el lenguaje C.</p>
</article>

      </div>
    </div>

    <footer>
  <div class="inner footer-inner">
    <div>
      &copy; 1997-2019 Francisco Charte.
      
      <nav class="main-navigation">
  
  <a href="https://www.researchgate.net/profile/F_Charte">ResearchGate</a>
  
  <a href="http://orcid.org/0000-0002-3083-8942">ORCID</a>
  
  <a href="https://github.com/fcharte">GitHub</a>
  
  <a href="https://scholar.google.es/citations?user=i8l_80EAAAAJ&hl=es">Google Scholar</a>
  
</nav>

      
    </div>
    <p>Contenido distribuido bajo <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.es">CC BY-NC-ND 4.0</a></p>
  </div>
</footer>


  </body>
</html>
